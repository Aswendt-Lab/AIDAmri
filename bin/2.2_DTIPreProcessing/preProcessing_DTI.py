"""
Created on 10/08/2017

@author: Niklas Pallast
Neuroimaging & Neuroengineering
Department of Neurology
University Hospital Cologne

Edited by Paul Camacho 2025

"""


import nipype.interfaces.fsl as fsl
import os, sys
import nibabel as nii
import numpy as np
import applyMICO
import nipype.interfaces.ants as ants
import subprocess
import shutil
import averageb0
import dipy.denoise.patch2self as patch2self
import extracted_brain_output

def reset_orientation(input_file):

    brkraw_dir = os.path.join(os.path.dirname(input_file), "brkraw")
    if os.path.exists(brkraw_dir):
        return 

    os.mkdir(brkraw_dir)
    dst_path = os.path.join(brkraw_dir, os.path.basename(input_file))

    shutil.copyfile(input_file, dst_path)

    data = nii.load(input_file)
    raw_img = data.dataobj.get_unscaled()

    raw_nii = nii.Nifti1Image(raw_img, data.affine)
    nii.save(raw_nii, input_file)

    delete_orient_command = f"fslorient -deleteorient {input_file}"
    subprocess.run(delete_orient_command, shell=True)

    # Befehl zum Festlegen der radiologischen Orientierung
    forceradiological_command = f"fslorient -forceradiological {input_file}"
    subprocess.run(forceradiological_command, shell=True)


def applyBET(input_file,frac=0.40,radius=6,vertical_gradient=0.0,use_bet4animal=False, species='mouse', verbose=True):
    """Apply BET"""
    if use_bet4animal:
        # Use BET for animal brains - this does not work very well with some mouse diffusion data
        print("Using BET for animal brains")
        w_value = 2
        species_id = 6 if species == 'mouse' else 5
        output_file = os.path.join(os.path.dirname(input_file), os.path.basename(input_file).replace('.nii.gz', 'Bet.nii.gz'))
        bet4animal_cmd = f"/aida/bin/bet4animal {input_file} {output_file} -f {frac} -m -w {w_value} -z {species_id}"
        subprocess.run(bet4animal_cmd, shell=True)
        # rename mask file
        # Check for mask files generated by bet4animal with pattern Bet_bet4animal_XXXXX_brain_mask.nii.gz
        bet4animal_mask_files = [
            f for f in os.listdir(os.path.dirname(input_file))
            if f.startswith(os.path.basename(input_file).replace('.nii.gz', 'Bet_bet4animal_')) and f.endswith('brain_mask.nii.gz')
        ]
        output_mask_file = os.path.join(os.path.dirname(input_file), os.path.basename(input_file).split('.')[0] + 'BetMask.nii.gz')
        if os.path.exists(output_file):
            print(f"Brain extraction completed, output saved to {output_file}")
            mask_file = output_file.replace('Bet.nii.gz', 'Bet_mask.nii.gz')
            os.rename(mask_file, output_mask_file)
        elif bet4animal_mask_files:
            print(f"Found bet4animal mask file(s): {bet4animal_mask_files}")
            # change names for files ending in brain.nii.gz and brain_mask.nii.gz
            mask_file = os.path.join(os.path.dirname(input_file), bet4animal_mask_files[0])
            bet_file = mask_file.replace('_brain_mask.nii.gz', '.nii.gz')
            brain_file = mask_file.replace('brain_mask.nii.gz', 'brain.nii.gz')
            if os.path.exists(brain_file):
                print(f"Found brain file: {brain_file}")
                # if multiple files are found ending in brain.nii.gz, use extracted_brain_output to select the one with lower voxel sum
                extracted_file = extracted_brain_output.extracted_brain_output(os.path.dirname(input_file), os.path.basename(input_file).replace('.nii.gz', 'Bet.nii.gz'))
                print(f"Selected brain file: {extracted_file}")
                os.rename(extracted_file, output_file)
            else:
                os.rename(bet_file, output_file)
            os.rename(mask_file, output_mask_file)
            # os.rename(brain_file, output_brain_file)
        # os.rename(mask_file, output_mask_file)
        # copy geometry information from input file to output files using fslcpgeom
        for image in [output_file, output_mask_file]: # , output_brain_file
            fslcpgeom_cmd = f"fslcpgeom {input_file} {image}"
            subprocess.run(fslcpgeom_cmd, shell=True)
    else:
        # scale Nifti data by factor 10
        data = nii.load(input_file)
        imgTemp = data.get_fdata()
        if verbose is True:
            print("Image dimensions before scaling:", imgTemp.header.get_zooms())
        scale = np.eye(4) * 10
        scale[3][3] = 1
        imgTemp = np.flip(imgTemp, 2)
        if verbose is True:
            print("Image dimensions after scaling:", imgTemp.header.get_zooms())

        scaledNiiData = nii.Nifti1Image(imgTemp, data.affine * scale)
        if verbose is True:
            print("Image dimensions after flipping:", scaledNiiData.header.get_zooms())
        hdrIn = scaledNiiData.header
        hdrIn.set_xyzt_units('mm')
        scaledNiiData = nii.as_closest_canonical(scaledNiiData)

        fslPath = os.path.join(os.path.dirname(input_file), 'fslScaleTemp.nii.gz')
        nii.save(scaledNiiData, fslPath)
        if verbose is True:
            print("Saved scaled image to:", fslPath)
            print("Image dimensions:", scaledNiiData.header.get_zooms())

        # extract brain
        output_file = os.path.join(os.path.dirname(input_file), os.path.basename(input_file).split('.')[0] + 'Bet.nii.gz')

        myBet = fsl.BET(in_file=fslPath, out_file=output_file, frac=frac, radius=radius,
                        vertical_gradient=vertical_gradient, robust=True, mask=True)
        myBet.run()
        os.remove(fslPath)

        # unscale result data by factor 10Ë†(-1)
        dataOut = nii.load(output_file)
        imgOut = dataOut.get_fdata()
        scale = np.eye(4) / 10
        scale[3][3] = 1

        unscaledNiiData = nii.Nifti1Image(imgOut, dataOut.affine * scale)
        hdrOut = unscaledNiiData.header
        hdrOut.set_xyzt_units('mm')
        if verbose is True:
            print("Image dimensions after unscaling:", unscaledNiiData.header.get_zooms())
        nii.save(unscaledNiiData, output_file)
    print(f"Brain extraction completed, output saved to {output_file}")
    return output_file


def denoise_patch2self(input_file, output_path, b0_thresh=100):
    """
    Denoises the input DTI image using Patch2Self from DIPY.
    Requires an appropriate input file (input_file) and the output path (output_path).
    """
    bvalsname = input_file.replace(".nii.gz", ".bval")
    if not os.path.exists(bvalsname):
        try:
            bvalsname = input_file.replace(".nii.gz", ".btable")
            btable = np.loadtxt(bvalsname, dtype=float)
            bvalsname = os.path.splitext(bvalsname)[0] + ".bval"
            np.savetxt(bvalsname, btable[0, :], fmt='%.6f')
        except:
            sys.exit(f"Error: bvals file {bvalsname} not found.")
    bvals = np.loadtxt(bvalsname, dtype=float)
    data = nii.load(input_file)
    img = data.get_fdata()
    affine = data.affine
    debug = True
    if debug is True:
        print("Debugging information:")
        print("Image header:", data.header)
        print("Affine matrix:", affine)
        print("Image sform:", data.header.get_sform())
    if img.ndim != 4:
        raise ValueError("Input image must be a 4D NIfTI file.")
    
    # Apply Patch2Self denoising
    denoised_img = patch2self.patch2self(img, bvals, b0_threshold=b0_thresh, model='ols', out_dtype=np.int16)
    
    # Save the denoised image
    output_file = os.path.join(output_path, os.path.basename(input_file).split('.')[0] + 'Patch2SelfDenoised.nii.gz')
    denoised_nii = nii.Nifti1Image(denoised_img, affine)
    denoised_nii.header.set_xyzt_units('mm')
    if debug is True:
        print("Denoised image header:", denoised_nii.header)
        print("Denoised affine matrix:", denoised_nii.affine)
        print("Denoised image sform:", denoised_nii.header.get_sform())
    nii.save(denoised_nii, output_file)

    # # Copy header from original image to denoised image using fslcpgeom
    # myFslCpGeom = fsl.utils.CopyGeom(dest_file=output_file, in_file=input_file)
    # myFslCpGeom.run()
    # print(f"Denoising completed, output saved to {output_file}")
    # if debug is True:
    #     output = nii.load(output_file)
    #     print("Final denoised image header after copying geometry:", output.header)
    #     print("Final denoised affine matrix after copying geometry:", output.affine)
    #     print("Final denoised image sform after copying geometry:", output.header.get_sform())
    return output_file


# def denoise_mppca(input_file, output_path):
#     """
#     Denoises the input DTI image using MP-PCA (as inplemented in MRtrix3)
#     Requires an appropriate input file (input_file) and the output path (output_path).
#     """
#     data = nii.load(input_file)
#     img = data.get_fdata()
#     affine = data.affine
#     debug = True
#     if debug is True:
#         print("Debugging information:")
#         print("Image header:", data.header)
#         print("Affine matrix:", affine)
#         print("Image sform:", data.header.get_sform())
#     if img.ndim != 4:
#         raise ValueError("Input image must be a 4D NIfTI file.")

#     # Apply MP-PCA denoising
#     denoised_img = mppca.mppca(img, n_components=5)

#     # Save the denoised image
#     output_file = os.path.join(output_path, os.path.basename(input_file).split('.')[0] + 'MPPCA_Denoised.nii.gz')
#     denoised_nii = nii.Nifti1Image(denoised_img, affine)
#     denoised_nii.header.set_xyzt_units('mm')
#     if debug is True:
#         print("Denoised image header:", denoised_nii.header)
#         print("Denoised affine matrix:", denoised_nii.affine)
#         print("Denoised image sform:", denoised_nii.header.get_sform())
#     nii.save(denoised_nii, output_file)

#     return output_file


def dwibiasfieldcorr(input_file,outputPath):
    output_file = os.path.join(outputPath, os.path.basename(input_file).split('.')[0] + 'N4Bias.nii.gz')
    # Note: shrink_factor is set to 4 to speed up the process, but can be adjusted
    myAnts = ants.N4BiasFieldCorrection(input_image=input_file,output_image=output_file,
                                        shrink_factor=4,bspline_fitting_distance=20,
                                        bspline_order=3,n_iterations=[1000,0],dimension=3)
    myAnts.run()
    print("Biasfield correction completed")
    return output_file


def smoothIMG(input_file, output_path,skip_min=False):
    """
    Smoothes image via FSL. Only input and output has do be specified. Parameters are fixed to box shape and to the kernel size of 0.1 voxel.
    If skip_min is True, the minimum filter is not applied, and the image is directly smoothed (No "DN" files are produced).
    """
    data = nii.load(input_file)
    vol = data.get_fdata()
    if skip_min is False or str(skip_min).lower() == 'false':
        ImgSmooth = np.min(vol, 3)
        unscaledNiiData = nii.Nifti1Image(ImgSmooth, data.affine)
        hdrOut = unscaledNiiData.header
        hdrOut.set_xyzt_units('mm')
        output_file = os.path.join(os.path.dirname(input_file),
                                   os.path.basename(input_file).split('.')[0] + 'DN.nii.gz')
        nii.save(unscaledNiiData, output_file)
        input_file = output_file
    else:
        ImgSmooth = vol

    output_file = os.path.join(output_path, os.path.basename(input_file).split('.')[0] + 'Smooth.nii.gz')
    myGauss =  fsl.SpatialFilter(
        in_file = input_file,
        out_file = output_file, 
        operation = 'median',
        kernel_shape = 'box',
        kernel_size = 0.1
    )
    myGauss.run()
    return output_file

def thresh(input_file, output_path):
    #output_file = os.path.join(os.path.dirname(input_file),os.path.basename(input_file).split('.')[0]+ 'Thres.nii.gz')
    output_file = os.path.join(output_path, os.path.basename(input_file).split('.')[0] + 'Thres.nii.gz')
    myThres = fsl.Threshold(in_file=input_file,out_file=output_file,thresh=20)#,direction='above')
    myThres.run()
    return output_file

def cropToSmall(input_file,output_path):
    #output_file = os.path.join(os.path.dirname(input_file),os.path.basename(input_file).split('.')[0]  + 'Crop.nii.gz')
    output_file = os.path.join(output_path, os.path.basename(input_file).split('.')[0] + 'Crop.nii.gz')
    myCrop = fsl.ExtractROI(in_file=input_file,roi_file=output_file,x_min=40,x_size=130,y_min=50,y_size=110,z_min=0,z_size=12)
    myCrop.run()
    return  output_file


if __name__ == "__main__":
    import argparse


    parser = argparse.ArgumentParser(description='Preprocessing of DTI Data')

    requiredNamed = parser.add_argument_group('required named arguments')
    requiredNamed.add_argument(
        '-i',
        '--input',
        help='Path to the raw NIfTI DTI file',
        required=True,
    )

    parser.add_argument(
        '-f',
        '--frac',
        help='Fractional intensity threshold - default=0.4, smaller values give larger brain outline estimates',
        nargs='?',
        type=float,
        default=0.4,
    )
    parser.add_argument(
        '-r',
        '--radius',
        help='Head radius (mm not voxels) - default=45',
        nargs='?',
        type=int,
        default=45,
    )
    parser.add_argument(
        '-g',
        '--vertical_gradient',
        help='Vertical gradient in fractional intensity threshold - default=0.0, positive values give larger brain outlines at bottom and smaller brain outlines at top',
        nargs='?',
        type=float,
        default=0.0,
    )
    parser.add_argument(
        '-d',
        '--denoiser',
        help='Denoising method - default=None, other option is "patch2self"',
        default=None,
        nargs='?',
        type=str,
    )
    parser.add_argument(
        '-b',
        '--biasfieldcorr',
        help='Biasfield correction method - default=None, other options are "mico" or "ants"',
        nargs='?',
        type=str,
        default=None,
    )
    parser.add_argument(
        '-bet4animal',
        '--use_bet4animal',
        help='Set value to True to use BET for animal brains',
        nargs='?',
        type=bool,
        default=False,
    )
    parser.add_argument(
        '-deoblique',
        '--deoblique_input_file',
        help='Set value to True to deoblique the input file using AFNI 3dWarp -deoblique',
        nargs='?',
        type=bool,
        default=False,
    )
    parser.add_argument(
        '-averageb0',
        '--average_b0',
        help='Set value to True to average the b0 volumes',
        nargs='?',
        type=bool,
        default=False,
    )
    parser.add_argument(
        '-skip_min',
        '--skip_min',
        help='Set value to True to skip the minimum filter before smoothing',
        nargs='?',
        type=bool,
        default=False,
    )
    args = parser.parse_args()

    # set parameters
    input_file = None
    if args.input is not None and args.input is not None:
        input_file = args.input

    if not os.path.exists(input_file):
        sys.exit("Error: '%s' is not an existing directory or file %s is not in directory." % (input_file, args.file,))
        
    frac = args.frac
    radius = args.radius
    vertical_gradient = args.vertical_gradient
    output_path = os.path.dirname(input_file)
    b0_thresh=100

    print(f"Frac: {frac} Radius: {radius} Gradient {vertical_gradient}")

    reset_orientation_needed = True
    if reset_orientation_needed:
        reset_orientation(input_file)
        print("Orientation reset to RAS")
    
    if args.denoiser == "patch2self":
        # Denoising using Patch2Self
        denoised_image = denoise_patch2self(input_file, output_path, b0_thresh)
        print("Denoising completed, output saved to", denoised_image)
        # reset_orientation(denoised_image)
        input_file = denoised_image

    if args.average_b0 is True:
        # Average b0 volumes
        b0image = averageb0.averageb0(input_file,b0_thresh)
        # # Copy header with fslcopygeom
        # myFslCpGeom = fsl.utils.CopyGeom(dest_file=b0image, in_file=input_file)
        # myFslCpGeom.run()
        input_file = b0image
        print("Averaging b0 volumes completed, output saved to", input_file)

    try:
        output_smooth = smoothIMG(input_file = input_file, output_path = output_path, skip_min=args.skip_min)
        print("Smoothing completed")
    except Exception as e:
        print(f'Fehler in der Biasfieldcorrecttion\nFehlermeldung: {str(e)}')
        raise
    
    if args.biasfieldcorr is None:
        print("No bias field correction applied")
        output_biascorr = output_smooth
    elif args.biasfieldcorr == "mico":
        # intensity correction using MICO
        try:
            output_biascorr = applyMICO.run_MICO(output_smooth, output_path)
            print("Biasfield correction was successful")
        except Exception as e:
            print(f'Error in bias field correction\nError message: {str(e)}')
            raise
    elif args.biasfieldcorr == "ants":
        # intensity correction using ANTs N4BiasFieldCorrection
        try:
            output_biascorr = dwibiasfieldcorr(input_file=output_smooth, outputPath=output_path)
            print("Biasfield correction was successful")
        except Exception as e:
            print(f'Error in bias field correction\nError message: {str(e)}')
            raise

    # get rid of your skull         
    outputBET = applyBET(input_file = output_biascorr, frac = frac, radius = radius, use_bet4animal=args.use_bet4animal)
    print("Brain extraction was successful")



















